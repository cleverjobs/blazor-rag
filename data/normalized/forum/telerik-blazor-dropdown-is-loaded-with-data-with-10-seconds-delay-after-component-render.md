# Telerik blazor dropdown is loaded with data with 10 seconds delay after component render

## Question

**Bim** asked on 25 May 2025

Hi Folks, For the below component the dropdown loads the data only after 10 seconds or so after the component is rendered on the browser. How would I get it to load immediately on the component load and not show the "No data" message on dropdown selection. The dropdown is loaded with data from an api service to an oracle database and it returns about 100 records. @page "/Startup" @rendermode @(new InteractiveServerRenderMode(prerender: false)) @using ance.UI.Components.Layout @layout MainLayout @inject NavigationManager Navigation @inject tenance.UI.Services.ApiService apiService @inject Blazored.SessionStorage.ISessionStorageService sessionStorage @using sMaintenance.UI.Dtos @using Microsoft.AspNetCore.Http @using Microsoft.AspNetCore.DataProtection @using estExtensions.Core.Principal @using System.Text.Json; @using System.IO; @inject IHttpContextAccessor HttpContextAccessor @inject IDataProtectionProvider DataProtectionProvider @inject IConfiguration configuration; @inject GlobalTokenContainer globalTokenContainer; <h1> Test Page</h1> <label class="card-title">Select : </label> <TelerikDropDownList Data="@Testdata" TextField="UserName" ValueField="NewideId" @bind-Value="selectedValue" OnChange="@OnUserSelectionChanged" Width="20%" /> <br /> <br /><br /> <div style="display: flex; gap: 1rem; align-items: center;"> <div style="display: flex; align-items: center; gap: 0.5rem;"> <label class="card-title">NewwideID : </label> <TelerikTextBox @bind-Value="@Name" Width="150px" ReadOnly="@true"/> </div> <div style="display: flex; align-items: center; gap: 0.5rem;"> <label class="card-title">Role : </label> <TelerikTextBox @bind-Value="@Role" Width="150px" ReadOnly="@true" /> </div> </div> <br /> <div> <label class="card-title">demo No. : </label> <TelerikTextBox @bind-Value="@ClaimNo" Width="20%" /> </div> <br /> <div> <TelerikButton OnClick="@GoToClms" ThemeColor="@(ThemeConstants.Button.ThemeColor.Primary)">GO</TelerikButton> <TelerikButton>Send Letter</TelerikButton> <TelerikButton OnClick="@GoToOtherPage">Catastrophe Manager</TelerikButton> </div> <br /> @if (!string.IsNullOrEmpty(warningMessage)) { <div class="alert alert-danger">Global token is empty </div> } @code { private string? NewideID; private string Role="Adjster"; private string? ClaimNo; public string? Name; private string Token=string.Empty; private List<AdjerDto> adjusters=new(); private string? selectedValue; private string? globalToken; private const string CookieName="UserInfo"; private const bool V=true; private string cookieValue=""; private string? warningMessage; private string? baseHref; public async Task GetOrFetchTokenAsync(string nwideId) { // Check if the token exists in session storage var globalToken=await sessionStorage.GetItemAsync<string>("gltoken"); var wetoken=await sessionStorage.GetItemAsync<string>("wetoken"); if (string.IsNullOrEmpty(gltoken)) { gltoken=await apiService.GetGlobalTokenAsync(newideId); if (!string.IsNullOrEmpty(gltoken)) { // Store the fetched token in session storage await sessionStorage.SetItemAsync("globaltoken", gltoken); globalTokenConer.GlolToken=gltoken; } } if (string.IsNullOrEmpty(cimToken)) { wetoken=await apiService.GetCimTokenAsync(newideId); if (!string.IsNullOrEmpty(cimToken)) { // Store the fetched token in session storage await sessionStorage.SetItemAsync("cimtoken", cimToken); } } } // Method to handle navigation to the Catastrophe Management page after obtaining a global token private async Task GoToOtherPage() { try { // Reset the global token to ensure a fresh start globalToken=string.Empty; // Proceed only if a Name is provided if (Name is not null) { // Fetch or retrieve token for the provided Name (possibly from a cache or API) await GetOrFetchTokenAsync(Name); // Attempt to get the actual global token from the API globalToken=await apiService.GetGlobalTokenAsync(Name); // Log and check if the token is successfully retrieved if (!string.IsNullOrWhiteSpace(globalToken)) { Console.WriteLine($"Received Global Token: {globalToken}"); } else { // Set a warning message if the token is null or empty warningMessage=$"Warning: API returned an empty or null token for {Name}"; Console.WriteLine(warningMessage); // Trigger UI update and exit the method early StateHasChanged(); return; } // Update the UI to reflect new state StateHasChanged(); } // Store the global token in the browser's session storage await sessionStorage.SetItemAsync("globaltoken", globalToken); // If token is valid, clear warning message and navigate to the Catastrophe Management page if (!string.IsNullOrWhiteSpace(globalToken)) { warningMessage=string.Empty; Navigation.NavigateTo($"{baseHref}CatastrophePages/CatastropheManagement?globalToken={globalToken}", true); } } catch (Exception ex) { // Log any exceptions that occur during the process Console.WriteLine(ex.Message); } } private async Task GoToClms() { try { gloToken=string.Empty; if (Name is not null) { await GetOrFetchTokenAsync(Name); glToken=await apiService.GetGlobalTokenAsync(Name); if (!string.IsNullOrWhiteSpace(glToken )) { Console.WriteLine($"Received Global Token: {glToken }"); } else { warningMessage=$"Warning: API returned an empty or null token for {Name}"; Console.WriteLine($"Warning: API returned an empty or null token for { Name}"); StateHasChanged(); return; } StateHasChanged(); } await sessionStorage.SetItemAsync("globaltoken", glToken ); if (!string.IsNullOrWhiteSpace(ClaimNo) && !string.IsNullOrWhiteSpace(glToken )) { warningMessage=string.Empty; Navigation.NavigateTo($"{baseHref}ClaimDetails/{ClaimNo}?globalToken={glToken }", true); } else if (!string.IsNullOrWhiteSpace(globalToken)) { warningMessage=string.Empty; Navigation.NavigateTo($"{baseHref}Claitory?globalToken={glToken }", true); } } catch (Exception ex) { Console.WriteLine(ex.Message); } } // Component Initialization code protected override async Task OnInitializedAsync() { await sessionStorage.SetItemAsync("name", "John Smith"); var name=await sessionStorage.GetItemAsync<string>("name"); warningMessage=string.Empty; baseHref=configuration.GetValue<string>("baseHref"); Testdata=await GetLoadAersAsync(); } // Adjuster Dropdown list selection changed event private async Task OnUserSelectionChanged(object value) { warningMessage=string.Empty; if (value is string selectedNwideId) { Name=selectedNwideId; globalToken=await apiService.GetGlobalTokenAsync(Name); } StateHasChanged(); } // Fetch from the API public async Task<List<AdstrDto>> GetLoadAdjusAsync() { var response=await apiService.GetjustersAsync(); return response ?? new List<AdstrDto>(); } }

## Answer

**Nadezhda Tacheva** answered on 28 May 2025

Hi Bimal, The general good practice to improve the performance of the DropDownList when working with large data sets is to enable virtualization: [https://www.telerik.com/blazor-ui/documentation/components/dropdownlist/virtualization.](https://www.telerik.com/blazor-ui/documentation/components/dropdownlist/virtualization.) This feature allows you to fetch only small chunks of data as the user scrolls instead of fetching the whole data source on initialization. Apart from that, you may check how long the service takes to retrieve the requested records. This does not depend on the DropDownList but if the service takes a while to fetch the data, this delay will inevitably be seen in the UI of the DropDownList. Regards, Nadezhda Tacheva Progress Telerik
